#Fonction faisant la K_cross_validation de l'algo et calculant les moyennes des performances
#Cross validation peut se faire à deux moments: soit pour tester le classifieur, sans SVM, soit pour tester le SVM
#Pour le SVM, Permet comme entrée plusieurs gamma et costs
#Pour le SVM: output = performances classifieur sur les différents niveaux de confiance prédits, avec leur taille

K_cross_valid <- function(data,MMap,Mgbd,Egbd,MT,MTEB,K,alpha,wsd,gamma,cost,COND,COND_only){
#Si gamma = NULL et cost = NULL, on fait l'évaluation du classifieur sans SVM
#Si gamma et cost != NULL, on fait l'évaluation du classifieur sur les prédictions du SVM

labs <- 0:nrow(Mgbd)
x <- sample(1:nrow(data))
L <- split(x,ceiling(seq_along(x)/(length(x)/K)))

Ptot <- c()
Ptot_class <- c()

t0 <- proc.time()
for(i in 1:K){
#i <- sample(1:K,1)
trdt <- data[unlist(L[-i]),]
NCTstr <- tolower(as.character(trdt$PMID))
Mtr <- droplevels(MMap[MMap$NCT%in%paste("pbky",NCTstr,sep=""),])

tsdt <- data[unlist(L[i]),]
NCTsts <- tolower(as.character(tsdt$PMID))
Mts <- droplevels(MMap[MMap$NCT%in%paste("pbky",NCTsts,sep=""),])

TR <- training(trdt,Mgbd,Egbd,Mtr,MT,MTEB,alpha,wsd,gamma,cost,COND,COND_only)
#Si gamma = NULL et cost = NULL, svm_mod_wrong = NULL

MTc <- TR[[1]]
svm_mod_wrong <- TR[[2]]

CL <- classifier(tsdt,Mts,MTc,wsd,svm_mod_wrong,COND,COND_only)
#Si svm_mod_wrong = NULL, l'output du classifieur est classif + NULL
#Si svm_mod_wrong != NULL, l'output du classifieur est classif + prediction SVM

PERF <- Eval_CL(tsdt, CL)
Ptot <- c(Ptot,list(PERF))

PERF_class <- Eval_per_class_CL(tsdt, CL, labs)
Ptot_class <- c(Ptot_class,list(PERF_class))
}
t1 <- proc.time() - t0
#4.9min for 5 gamma and 3 cost
#50s for NoSVM

#Si SVM
#On renvoit 2 éléments
#1- Pourcentage, Precision, Recall, Exact-match moyen pour chaque sous-ensemble (en colonnes) et chaque SVM (en lignes)
#2- Sens et Spec moyen across categories pour chaque sous-ensemble (en colonnes) et chaque SVM (en lignes)
if(length(gamma)!=0 & length(cost)!=0){
Prms <- cbind(rep(gamma,each=length(cost)),rep(cost,times=length(gamma)))
return(list(
#
cbind(Prms,apply(simplify2array(Ptot), c(1,2), function(d){mean(d,na.rm=TRUE)})),
#Pour chaque étape de la fold valid
cbind(Prms,apply(simplify2array(
lapply(Ptot_class,function(x){	do.call('rbind',
				#Pour chaque SVM
				lapply(x,function(y){
					#Pour chaque sous-ensemble de prédiction on fait la moyenne across categories
					unlist(lapply(y,function(z){apply(z[,2:3],2,function(t){mean(t,na.rm=TRUE)})}))
					}))
					})), c(1,2), function(d){mean(d,na.rm=TRUE)}))
))
}

#Si NoSVM
#ON renvoit 3 éléments
#1- Precision, Recall, Exact-match moyen
#2- Sensibilité et Spécificité moyenne pour chaque catégorie
#3- Sensibilité et Spécificité moyen across catégories: pour chaque étape de la cross valid on fait la moyenne des spec et sens des catégories
else return(list(apply(simplify2array(Ptot), 1, function(d){mean(d,na.rm=TRUE)}),
 		apply(simplify2array(Ptot_class), c(1,2), function(d){mean(d,na.rm=TRUE)}),
		apply(simplify2array(lapply(Ptot_class,function(x){apply(x[,2:3],2,function(y){mean(y,na.rm=TRUE)})})),1,mean)
		))
}
