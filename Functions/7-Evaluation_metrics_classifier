#Precision and Recall pour classif/unclassif
####################################################
#Sensibilité = Recall
Sens_class <- function(pred,data){
sum(pred&data)/sum(data)
}

#Spécificité
Spec_class <- function(pred,data){
sum(!pred&!data)/sum(!data)
}

#Precision = valeur prédictive positive
Prec_class <- function(pred,data){
sum(pred&data)/sum(pred)
}

#Valeur prédictive négative
Vpn_class <- function(pred,data){
sum(!pred&!data)/sum(!pred)
}

####################################################################
#Measures for multi-label classification
#Input = forme de listes de listes
#Rq: pour ces mesures on enlève les NoGBD des deux côtés
#Ou bien on peut donner 0 au groupe NoGBD

#On donne le gpe 0 aux classif vides pour formule dans l'algèbre du pb =)
AjoutZ <- function(d){
data0 <- d
data0[unlist(lapply(data0,length))==0] <- 0
return(data0)
}

#####################################################################
#Trial based measures
#####################################################################

SubsetAcc <- function(algo0,data0){
#Exact match ratio
if(length(data0)==0) return(NA)
mean(as.numeric(unlist(lapply(1:length(data0),function(i){setequal(data0[[i]],algo0[[i]])}))))
}

Prec_t <- function(algo0,data0){
#Mean of Percentages of retrieved categories that are relevant
#On donne le gpe 0 aux classif vides pour formule dans l'algèbre du pb =)
if(length(data0)==0) return(NA)
mean(unlist(lapply(1:length(data0),function(i){length(intersect(data0[[i]],algo0[[i]]))/length(algo0[[i]])})))
}

Rec_t <- function(algo0,data0){
#Mean of Percentages of the relevant categories that are retrieved
if(length(data0)==0) return(NA)
mean(unlist(lapply(1:length(data0),function(i){length(intersect(data0[[i]],algo0[[i]]))/length(data0[[i]])})))
}

sym_diff <- function(a,b) setdiff(union(a,b), intersect(a,b))

HammingLoss <- function(algo0,data0,lab){
#lab désigne la taille de l'espace des labels
if(length(data0)==0) return(NA)
mean(as.numeric(unlist(lapply(1:length(data0),function(i){length(sym_diff(data0[[i]],algo0[[i]]))}))))/lab
}

Acc_t <- function(algo0,data0){
#Mean of Percentages of overall match
if(length(data0)==0) return(NA)
mean(unlist(lapply(1:length(data0),function(i){length(intersect(data0[[i]],algo0[[i]]))/length(unique(union(algo0[[i]],data0[[i]])))})))
}

###################################################################
#Category based measures
###########################################

#True positives pour la catégorie gbd (numeric %in%0:171)
TP <- function(algo0,data0,gbd){
sum(as.numeric(unlist(lapply(data0,function(x){gbd%in%as.numeric(x)})))*as.numeric(unlist(lapply(algo0,function(x){gbd%in%as.numeric(x)}))))
}

#False positives
FP <- function(algo0,data0,gbd){
sum(as.numeric(unlist(lapply(data0,function(x){!gbd%in%as.numeric(x)})))*as.numeric(unlist(lapply(algo0,function(x){gbd%in%as.numeric(x)}))))
}

#True negatives
TN <- function(algo0,data0,gbd){
sum(as.numeric(unlist(lapply(data0,function(x){!gbd%in%as.numeric(x)})))*as.numeric(unlist(lapply(algo0,function(x){!gbd%in%as.numeric(x)}))))
}

#False negatives
FN <- function(algo0,data0,gbd){
sum(as.numeric(unlist(lapply(data0,function(x){gbd%in%as.numeric(x)})))*as.numeric(unlist(lapply(algo0,function(x){!gbd%in%as.numeric(x)}))))
}

conf_matrix <- function(algo0,data0,lab_list){
do.call(rbind,lapply(lab_list,function(l){c(TP(algo0,data0,l),FP(algo0,data0,l),TN(algo0,data0,l),FN(algo0,data0,l))}))
}

Acc_l <- function(vals){
tp <- vals[1]
fp <- vals[2]
tn <- vals[3]
fn <- vals[4]
(tp+tn)/(tp+fp+tn+fn)
}

Prec_l <- function(vals){
tp <- vals[1]
fp <- vals[2]
tn <- vals[3]
fn <- vals[4]
tp/(tp+fp)
}

#Sensibilité = Recall
Sens_l <- function(vals){
tp <- vals[1]
fp <- vals[2]
tn <- vals[3]
fn <- vals[4]
tp/(tp+fn)
}

#Spécificité
Spec_l <- function(vals){
tp <- vals[1]
fp <- vals[2]
tn <- vals[3]
fn <- vals[4]
tn/(tn+fp)
}


macro_av <- function(cm,fun){
mean(apply(cm,1,fun))
}

micro_av <- function(cm,fun){
fun(apply(cm,2,sum))
}

###############################
#Conf matrix SVM
#True positives pour le label predit (character%in% No, Included, Yes)
TP_svm <- function(algo0,data0,lab){sum((algo0==lab)*(data0==lab))}

#False positives
FP_svm <- function(algo0,data0,lab){sum((algo0==lab)*(data0!=lab))}

#True negatives
TN_svm <- function(algo0,data0,lab){sum((algo0!=lab)*(data0!=lab))}

#False negatives
FN_svm <- function(algo0,data0,lab){sum((algo0!=lab)*(data0==lab))}

conf_matrix_svm <- function(algo0,data0,lab_list){
do.call(rbind,lapply(lab_list,function(l){c(TP_svm(algo0,data0,l),FP_svm(algo0,data0,l),TN_svm(algo0,data0,l),FN_svm(algo0,data0,l))}))
}

