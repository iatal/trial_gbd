#Fonction qui renvoit, en fonction d'un input (NCTs,MMap), en fonction de l'output du training, à savoir MTc (IntraMap donné par alpha dans training) et svm_mod: modèle svm, et en fonction de quelques paramètres: wsd_classif: utilise-t-on les données wsd pour la classification (prédiction svm du test set + classification GBD)
#data nécessite avoir PMID connecté à MMap
#et brief_ off_ cond pour Nb_mots
#Rq: wsd_classif = Yes ou No pas de wsd Duo car on va prédire la classif pour un seul
#On ne prédit que pour les essais sans GBD

classifier <- function(data,MMap,MTc,wsd,inc_nogbd_svm,svm_mod_unclear,svm_mod_wrong,COND=FALSE,COND_only=FALSE){

NCTs <- as.character(data$PMID)

A <- Test_add_MT_classif(NCTs,MMap,MTc)
if(A[[1]]==FALSE) return(A[[3]])

MC <- CUI_charac(Mgbd, Egbd, MMap, MTc)

#On fait le processing pour chaque essai pour wsd
i <- 1
NCT <- paste("pbky",NCTs[i],sep="")
D <- Trial_charac(Mgbd,Egbd,NCT,MMap,MC,wsd,COND)
for(i in 2:length(NCTs)){
NCT <- paste("pbky",NCTs[i],sep="")
D <- rbind(D,Trial_charac(Mgbd,Egbd,NCT,MMap,MC,wsd,COND))
}
#30s pour 1500 essais

D <- data.frame(D,row.names=NULL)
D <- cbind(D,Nb_mots_chp(data))

ifelse(COND_only,gbd <- as.character(D$cond_GBD),gbd <- as.character(D$Ess_GBD))

#On enlève les GBD group lists et transforme tout en chiffres pour modèle prédictif
D <- D[,-grep("_GBD$",names(D))]
D <- sapply(D,function(x){as.numeric(as.character(x))})

#Pour la prédiction NoGBD/Unclear:
#Est-ce qu'on inclut ou pas le noGBD dans la prédiction?
#Le inc_nogbd_svm doit être le même que pour le training
#Rq: si inc_nogbd_svm = FALSE: attention au recollement predictions svm et gbd, car de différente taille
#    dans ce cas, prédiction ne vaut que pour les gbd!="" 
if(inc_nogbd_svm==FALSE) d <- D[gbd!="",]
else d <- D

#Prédiction de NoGBD
is_unclear <- predict(svm_mod_unclear$best.model,d)

#Prédiction de WrongGBD
#Pour la prédiction WrongGBD, on fait toujours avec toute la data
wrong_gbd <- predict(svm_mod_wrong$best.model,D)

return(list(gbd,is_unclear,wrong_gbd))

}

