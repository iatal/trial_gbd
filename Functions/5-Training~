#Fonction qui donne MTc en fonction de alpha, et l'output du training du svm en fonction des param
#SVM1 modèle prédictif: est-ce que l'essai a un GBD ou pas
#Pour le SVM1, On a l'option de prédire d'avance que l'essai n'a pas de GBD (inc_nogbd_svm = FALSE)
#Ou bien d'exclure les essais sans GBD de la base d'entrainement
#SVM2 modèle prédictif: est-ce que je suis classifié correctement ou pas?
#Pour SVM2: On peut faire 3 niveaux: Yes, No, Included
#output: modèle prédictif, en fonction des charact. de l'essai, est-ce qu'on peut être sûr de la classif donnée par le classifieur

training <- function(data,Mgbd,Egbd,MMap,MT,MTEB,alpha,wsd,inc_nogbd_svm,gamma,cost,COND=FALSE){
#gamma et cost peuvent être des vecteurs, on fait un tune svm

NCTs <- as.character(data$PMID)

A <- Test_add_MT(NCTs,MMap,MT,MTEB,alpha)

#Si pas besoin d'ajout, création de MTc
if(A[[1]]) MTc <- A[[2]]
#Sinon, on renvoie la liste de concepts à classifier
else return(A[[3]])

#Characteristiques CUI
MC <- CUI_charac(Mgbd,Egbd,MMap, MTc)

#On fait le processing pour chaque essai pour wsd
i <- 1
NCT <- paste("pbky",NCTs[i],sep="")
D <- Trial_charac(Mgbd,Egbd,NCT,MMap,MC,wsd,COND)
for(i in 2:length(NCTs)){
NCT <- paste("pbky",NCTs[i],sep="")
D <- rbind(D,Trial_charac(Mgbd,Egbd,NCT,MMap,MC,wsd,COND))
}
D <- data.frame(D,row.names=NULL)
D <- cbind(D,Nb_mots_chp(data))

#SVM1: NoGBD or YesGBD
#Test SVM: Unclear or not
D$Unclear <- factor(data$GBDnp=="")
#SVM model
mdl1 <- sup_vm(D,inc_nogbd_svm,gamma,cost)

#SVM2: WrongGBD or CorrectGBD
#Uncertainty: No si set equal, Included si intersection, Yes si erreur
tst <- strsplit(as.character(data$GBDnp),"&&")
algo <- strsplit(as.character(D$Ess_GBD),"&")
D$Unclear <- factor(unlist(lapply(1:nrow(data),function(x){	if(setequal(algo[[x]],tst[[x]])) return("No")
						else if(length(intersect(algo[[x]],tst[[x]]))>0) return("Included")
						else return("Yes")
						})))
#SVM model
#Par défaut, on inclut tous les essais (inc_nogbd = TRUE)
mdl2 <- sup_vm(D,TRUE,gamma,cost)

return(list(MTc,mdl1,mdl2))

}

