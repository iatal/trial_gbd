#Evaluation of a classifier
#############################
#Perfs: Précision, Recall et SubsetAcc (exact-matching)
#Deux options: soit il y a de SVM, soit pas de SVM
#Si pas de SVM: perfs globales
#Si SVM: perfs sur chaque niveau de confiance prédit par le SVM
#Permet que dans CL il y a ait plusieurs svms.

Eval_CL <- function(tsdt, CL){

gbd <- CL[[1]]
wrg_SVM <- CL[[2]]

algo <- strsplit(gbd,"&")
dt <- as.character(tsdt$GBDnp)
tst <- strsplit(dt,"&&")


algo0 <- AjoutZ(algo)
tst0 <- AjoutZ(tst)

#Si pas de SVM: on donne les perfs sans exclure des données
if(length(wrg_SVM)==0){
#Trial based performances
PERF <- c(Prec_t(algo0,tst0),Rec_t(algo0,tst0),SubsetAcc(algo0,tst0))

}

#Si SVM: on calcule les perfs sur les sous-ensembles
#On met en lignes les différents SVMs
if(length(wrg_SVM)!=0){
PERF <- do.call('rbind',lapply(wrg_SVM,function(wrg_svm){

#SVM = No -> Exact-matching
algono <- algo0[wrg_svm=="No"]
tstno <- tst0[wrg_svm=="No"]
#SVM = Included -> Non-empty intersection
algoinc <- algo0[wrg_svm=="Included"]
tstinc <- tst0[wrg_svm=="Included"]
#SVM = Yes -> Empty intersection
algoyes <- algo0[wrg_svm=="Yes"]
tstyes <- tst0[wrg_svm=="Yes"]

PR <- c(sum(wrg_svm=="No")/nrow(tsdt),Prec_t(algono,tstno),Rec_t(algono,tstno),SubsetAcc(algono,tstno),
	sum(wrg_svm=="Included")/nrow(tsdt),Prec_t(algoinc,tstinc),Rec_t(algoinc,tstinc),SubsetAcc(algoinc,tstinc),
	sum(wrg_svm=="Yes")/nrow(tsdt),Prec_t(algoyes,tstyes),Rec_t(algoyes,tstyes),SubsetAcc(algoyes,tstyes))
return(PR)
}))
}

return(PERF)
}

#####################################################
#Category based performances
#For each category, from 0 to nrow(Mgbd)
#we evaluate the sensibility and specificity

Eval_per_class_CL <- function(tsdt, CL, labs){

gbd <- CL[[1]]
wrg_SVM <- CL[[2]]

algo <- strsplit(gbd,"&")
dt <- as.character(tsdt$GBDnp)
tst <- strsplit(dt,"&&")

algo0 <- AjoutZ(algo)
tst0 <- AjoutZ(tst)

#Si pas de SVM: perfs sur toute la data
if(length(wrg_SVM)==0){

CM <- conf_matrix(algo0,tst0,labs)
#les colonnes représentent: TP, FP, TN, FN
PERF <- cbind(CM[,1]+CM[,4],CM[,1]/(CM[,1]+CM[,4]),CM[,3]/(CM[,3]+CM[,2]))
#Nb essais dans le GBD, Sensibilité, Spécificité
#Rq: si pas d'occurrence d'une catégorie dans le test set (TP + FN = 0): sensibility = NaN
}

#Si SVM: perfs sur chaque niveau de confiance prédit
#Valable pour plusieurs SVMs
#Renvoie une liste avec pour chaque param du SVM, les perfs dans chaque sous-ensemble
else{

PERF <- lapply(wrg_SVM,function(wrg_svm){

#SVM = No -> Exact-matching
algono <- algo0[wrg_svm=="No"]
tstno <- tst0[wrg_svm=="No"]
#SVM = Included -> Non-empty intersection
algoinc <- algo0[wrg_svm=="Included"]
tstinc <- tst0[wrg_svm=="Included"]
#SVM = Yes -> Empty intersection
algoyes <- algo0[wrg_svm=="Yes"]
tstyes <- tst0[wrg_svm=="Yes"]

CM <- conf_matrix(algono,tstno,labs)
PERFno <- cbind(CM[,1]+CM[,4],CM[,1]/(CM[,1]+CM[,4]),CM[,3]/(CM[,3]+CM[,2]))
	
CM <- conf_matrix(algoinc,tstinc,labs)
PERFinc <- cbind(CM[,1]+CM[,4],CM[,1]/(CM[,1]+CM[,4]),CM[,3]/(CM[,3]+CM[,2]))

CM <- conf_matrix(algoyes,tstyes,labs)
PERFyes <- cbind(CM[,1]+CM[,4],CM[,1]/(CM[,1]+CM[,4]),CM[,3]/(CM[,3]+CM[,2]))

return(list(PERFno,PERFinc,PERFyes))
})

}

return(PERF)

}

#######################################################
#Evaluation SVM: on évalue à quel point on a bien prédit le groupe
######################

Eval_SVM <- function(tsdt, CL){

gbd <- CL[[1]]
wrg_SVM <- CL[[2]]

algo <- strsplit(gbd,"&")
dt <- as.character(tsdt$GBDnp)
tst <- strsplit(dt,"&&")

Unclear <- unlist(lapply(1:nrow(tsdt),function(x){	if(setequal(algo[[x]],tst[[x]])) return("No")
						else if(length(intersect(algo[[x]],tst[[x]]))>0) return("Included")
						else return("Yes")
						}))

RS <- do.call('rbind',lapply(wrg_SVM,function(wrg_svm){
CM <- conf_matrix_svm(as.character(wrg_svm),Unclear,c("No","Included","Yes"))
#TP, FP, TN, FN
#Average accuracy, Precision and recall per class averaged across classes
return(c(apply(cbind((CM[,1]+CM[,3])/(CM[,1]+CM[,2]+CM[,3]+CM[,4]),CM[,1]/(CM[,1]+CM[,2]),CM[,1]/(CM[,1]+CM[,4])),2,function(x){mean(x,na.rm=TRUE)}),
#Macro precisions and recall
sum(CM[,1])/sum(CM[,1]+CM[,2]),sum(CM[,1])/sum(CM[,1]+CM[,4])))
}))

return(cbind(RS[,1],2*RS[,2]*RS[,3]/(RS[,2]+RS[,3]),2*RS[,4]*RS[,5]/(RS[,4]+RS[,5])))

}

########################################################
#Evaluation per class
#Donne la sensibilité et spécificité pour chaque classe de la taxonomie d'arrivée
#Donne aussi le nombre d'essais par classe
#Le nombre d'essais exclus par classe pour les deux configs de SVM_wrong
#Et les perf par classe après exclusion
#labs = ensemble GBDs dans Tax (avec 0 inclus)
##############################

Eval_per_class_CL_svm <- function(tsdt, CL, labs){

gbd <- CL[[1]]
wrg_svm <- unlist(CL[[2]])

algo <- strsplit(gbd,"&")
dt <- as.character(tsdt$GBDnp)
tst <- strsplit(dt,"&&")

algo0 <- AjoutZ(algo)
tst0 <- AjoutZ(tst)

#Sans exclure les données
#Confusion matrix
#Colonnes = TP, FP, TN, FN
CM <- conf_matrix(algo0,tst0,labs)
#Nb essais dans le GBD, Sensibilité, Spécificité

PERF <- cbind(CM[,1]+CM[,4],CM[,1]/(CM[,1]+CM[,4]),CM[,3]/(CM[,3]+CM[,2]))
#Sensibilité = NaN -> GBD non atteint par mon algo
#Sensibilité: capacité à dire vrai quand c'est vrai
#Si Nb essais avec GBD = 0 et Sens = NaN -> Sens = 1
PERF[PERF[,1]==0 & is.nan(PERF[,2]),2] <- 1
#Spécificité: capacité à dire que le GBD n'est pas là quand il n'est pas là

P <- PERF

#Avec petite exclusion pas SVM Wrong
algoinc <- algo0[wrg_svm%in%c("No","Included")]
tstinc <- tst0[wrg_svm%in%c("No","Included")]
algoexc <- algo0[!wrg_svm%in%c("No","Included")]
tstexc <- tst0[!wrg_svm%in%c("No","Included")]

#Nb exclus par catégorie
CM <- conf_matrix(algoexc,tstexc,labs)
P <- cbind(P,CM[,1]+CM[,4])

#Perf sur inclus
CM <- conf_matrix(algoinc,tstinc,labs)
#Nb essais dans le GBD, Sensibilité, Spécificité

PERF <- cbind(CM[,1]+CM[,4],CM[,1]/(CM[,1]+CM[,4]),CM[,3]/(CM[,3]+CM[,2]))
PERF[PERF[,1]==0 & is.nan(PERF[,2]),2] <- 1

P <- cbind(P,PERF)

#Avec grosse exclusion par SVM Wrong
algoinc <- algo0[wrg_svm%in%c("No")]
tstinc <- tst0[wrg_svm%in%c("No")]
algoexc <- algo0[!wrg_svm%in%c("No")]
tstexc <- tst0[!wrg_svm%in%c("No")]

#Nb exclus par catégorie
CM <- conf_matrix(algoexc,tstexc,labs)
P <- cbind(P,CM[,1]+CM[,4])

#Perf sur inclus
CM <- conf_matrix(algoinc,tstinc,labs)
#Nb essais dans le GBD, Sensibilité, Spécificité

PERF <- cbind(CM[,1]+CM[,4],CM[,1]/(CM[,1]+CM[,4]),CM[,3]/(CM[,3]+CM[,2]))
PERF[PERF[,1]==0 & is.nan(PERF[,2]),2] <- 1

P <- cbind(P,PERF)

return(P)
}

