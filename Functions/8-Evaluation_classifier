#Evaluation of a classifier
#############################
#On évalue la sensibilité et la spécificité de chaque SVM
#Pour SVM Wrong: on considère comme vrais positifs les essais dont ma classif est correcte que j'ai dit que la classif était correcte
#Pour la tache de classification vers GBD:
#Plus la moyenne des precisions et recall par essai en tenant en compte chaque SVM, et sans SVM
#Permet que dans CL il y a ait plusieurs svms.

Eval_CL <- function(tsdt, CL){

gbd <- CL[[1]]
wrg_SVM <- CL[[2]]

algo <- strsplit(gbd,"&")
dt <- as.character(tsdt$GBDnp)
tst <- strsplit(dt,"&&")

#On calcule la Précision, Recall et SubsetAcc pour
#Les data exclues et incluses par SVM Wrong dans les deux configurations de celui-ci
#Et pourcentage de data exclues dans chaque cas

PERF <- c()

algo0 <- AjoutZ(algo)
tst0 <- AjoutZ(tst)

#Sans exclure des données
PERF <- rbind(PERF,c(0,NA,NA,NA,Prec_t(algo0,tst0),Rec_t(algo0,tst0),SubsetAcc(algo0,tst0)))

#Cas SVM vs No SVM
if(length(wrg_SVM)!=0){
PERF <- rbind(PERF,do.call('rbind',lapply(wrg_SVM,function(wrg_svm){
PR <- c()
#Avec petite exclusion par SVM Wrong
algoinc <- algo0[wrg_svm%in%c("No","Included")]
tstinc <- tst0[wrg_svm%in%c("No","Included")]
algoexc <- algo0[!wrg_svm%in%c("No","Included")]
tstexc <- tst0[!wrg_svm%in%c("No","Included")]

PR <- rbind(PR,c(sum(!wrg_svm%in%c("No","Included"))/nrow(tsdt),
Prec_t(algoexc,tstexc),
Rec_t(algoexc,tstexc),
SubsetAcc(algoexc,tstexc),
Prec_t(algoinc,tstinc),
Rec_t(algoinc,tstinc),
SubsetAcc(algoinc,tstinc)))

#Avec grosse exclusion par SVM Wrong
algoinc <- algo0[wrg_svm%in%c("No")]
tstinc <- tst0[wrg_svm%in%c("No")]
algoexc <- algo0[!wrg_svm%in%c("No")]
tstexc <- tst0[!wrg_svm%in%c("No")]

PR <- rbind(PR,c(sum(!wrg_svm%in%c("No"))/nrow(tsdt),
Prec_t(algoexc,tstexc),
Rec_t(algoexc,tstexc),
SubsetAcc(algoexc,tstexc),
Prec_t(algoinc,tstinc),
Rec_t(algoinc,tstinc),
SubsetAcc(algoinc,tstinc)))
return(PR)
})))
}

return(PERF)
}

########################################################
#Evaluation per class
#Donne la sensibilité et spécificité pour chaque classe de la taxonomie d'arrivée
#Donne aussi le nombre d'essais par classe
#Le nombre d'essais exclus par classe pour les deux configs de SVM_wrong
#Et les perf par classe après exclusion
#labs = ensemble GBDs dans Tax (avec 0 inclus)
##############################

Eval_per_class_CL <- function(tsdt, CL, labs){

gbd <- CL[[1]]
wrg_svm <- unlist(CL[[2]])

algo <- strsplit(gbd,"&")
dt <- as.character(tsdt$GBDnp)
tst <- strsplit(dt,"&&")

algo0 <- AjoutZ(algo)
tst0 <- AjoutZ(tst)

#Sans exclure les données
#Confusion matrix
#Colonnes = TP, FP, TN, FN
CM <- conf_matrix(algo0,tst0,labs)
#Nb essais dans le GBD, Sensibilité, Spécificité

PERF <- cbind(CM[,1]+CM[,4],CM[,1]/(CM[,1]+CM[,4]),CM[,3]/(CM[,3]+CM[,2]))
#Sensibilité = NaN -> GBD non atteint par mon algo
#Sensibilité: capacité à dire vrai quand c'est vrai
#Si Nb essais avec GBD = 0 et Sens = NaN -> Sens = 1
PERF[PERF[,1]==0 & is.nan(PERF[,2]),2] <- 1
#Spécificité: capacité à dire que le GBD n'est pas là quand il n'est pas là

P <- PERF

#Avec petite exclusion pas SVM Wrong
algoinc <- algo0[wrg_svm%in%c("No","Included")]
tstinc <- tst0[wrg_svm%in%c("No","Included")]
algoexc <- algo0[!wrg_svm%in%c("No","Included")]
tstexc <- tst0[!wrg_svm%in%c("No","Included")]

#Nb exclus par catégorie
CM <- conf_matrix(algoexc,tstexc,labs)
P <- cbind(P,CM[,1]+CM[,4])

#Perf sur inclus
CM <- conf_matrix(algoinc,tstinc,labs)
#Nb essais dans le GBD, Sensibilité, Spécificité

PERF <- cbind(CM[,1]+CM[,4],CM[,1]/(CM[,1]+CM[,4]),CM[,3]/(CM[,3]+CM[,2]))
PERF[PERF[,1]==0 & is.nan(PERF[,2]),2] <- 1

P <- cbind(P,PERF)

#Avec grosse exclusion par SVM Wrong
algoinc <- algo0[wrg_svm%in%c("No")]
tstinc <- tst0[wrg_svm%in%c("No")]
algoexc <- algo0[!wrg_svm%in%c("No")]
tstexc <- tst0[!wrg_svm%in%c("No")]

#Nb exclus par catégorie
CM <- conf_matrix(algoexc,tstexc,labs)
P <- cbind(P,CM[,1]+CM[,4])

#Perf sur inclus
CM <- conf_matrix(algoinc,tstinc,labs)
#Nb essais dans le GBD, Sensibilité, Spécificité

PERF <- cbind(CM[,1]+CM[,4],CM[,1]/(CM[,1]+CM[,4]),CM[,3]/(CM[,3]+CM[,2]))
PERF[PERF[,1]==0 & is.nan(PERF[,2]),2] <- 1

P <- cbind(P,PERF)

return(P)
}

