#Evaluation of a classifier
#############################
#Perfs: Précision, Recall et SubsetAcc (exact-matching)
#Deux options: soit il y a de SVM, soit pas de SVM
#Si pas de SVM: perfs globales
#Si SVM: perfs sur chaque niveau de confiance prédit par le SVM
#Permet que dans CL il y a ait plusieurs svms.

Eval_CL <- function(tsdt, CL){

gbd <- CL[[1]]
wrg_SVM <- CL[[2]]

algo <- strsplit(gbd,"&")
dt <- as.character(tsdt$GBDnp)
tst <- strsplit(dt,"&&")


algo0 <- AjoutZ(algo)
tst0 <- AjoutZ(tst)

#Si pas de SVM: on donne les perfs sans exclure des données
if(length(wrg_SVM)==0){
PERF <- c(Prec_t(algo0,tst0),Rec_t(algo0,tst0),SubsetAcc(algo0,tst0))
}

#Si SVM: on calcule les perfs sur les sous-ensembles
#On met en lignes les différents SVMs
if(length(wrg_SVM)!=0){
PERF <- do.call('rbind',lapply(wrg_SVM,function(wrg_svm){

#SVM = No -> Exact-matching
algono <- algo0[wrg_svm=="No"]
tstno <- tst0[wrg_svm=="No"]
#SVM = Included -> Non-empty intersection
algoinc <- algo0[wrg_svm=="Included"]
tstinc <- tst0[wrg_svm=="Included"]
#SVM = Yes -> Empty intersection
algoyes <- algo0[wrg_svm=="Yes"]
tstyes <- tst0[wrg_svm=="Yes"]

PR <- c(sum(wrg_svm=="No")/nrow(tsdt),Prec_t(algono,tstno),Rec_t(algono,tstno),SubsetAcc(algono,tstno),
	sum(wrg_svm=="Included")/nrow(tsdt),Prec_t(algoinc,tstinc),Rec_t(algoinc,tstinc),SubsetAcc(algoinc,tstinc),
	sum(wrg_svm=="Yes")/nrow(tsdt),Prec_t(algoyes,tstyes),Rec_t(algoyes,tstyes),SubsetAcc(algoyes,tstyes))
return(PR)
}))
}

return(PERF)
}

########################################################
#Evaluation per class
#Donne la sensibilité et spécificité pour chaque classe de la taxonomie d'arrivée
#Donne aussi le nombre d'essais par classe
#Le nombre d'essais exclus par classe pour les deux configs de SVM_wrong
#Et les perf par classe après exclusion
#labs = ensemble GBDs dans Tax (avec 0 inclus)
##############################

Eval_per_class_CL <- function(tsdt, CL, labs){

gbd <- CL[[1]]
wrg_svm <- unlist(CL[[2]])

algo <- strsplit(gbd,"&")
dt <- as.character(tsdt$GBDnp)
tst <- strsplit(dt,"&&")

algo0 <- AjoutZ(algo)
tst0 <- AjoutZ(tst)

#Sans exclure les données
#Confusion matrix
#Colonnes = TP, FP, TN, FN
CM <- conf_matrix(algo0,tst0,labs)
#Nb essais dans le GBD, Sensibilité, Spécificité

PERF <- cbind(CM[,1]+CM[,4],CM[,1]/(CM[,1]+CM[,4]),CM[,3]/(CM[,3]+CM[,2]))
#Sensibilité = NaN -> GBD non atteint par mon algo
#Sensibilité: capacité à dire vrai quand c'est vrai
#Si Nb essais avec GBD = 0 et Sens = NaN -> Sens = 1
PERF[PERF[,1]==0 & is.nan(PERF[,2]),2] <- 1
#Spécificité: capacité à dire que le GBD n'est pas là quand il n'est pas là

P <- PERF

#Avec petite exclusion pas SVM Wrong
algoinc <- algo0[wrg_svm%in%c("No","Included")]
tstinc <- tst0[wrg_svm%in%c("No","Included")]
algoexc <- algo0[!wrg_svm%in%c("No","Included")]
tstexc <- tst0[!wrg_svm%in%c("No","Included")]

#Nb exclus par catégorie
CM <- conf_matrix(algoexc,tstexc,labs)
P <- cbind(P,CM[,1]+CM[,4])

#Perf sur inclus
CM <- conf_matrix(algoinc,tstinc,labs)
#Nb essais dans le GBD, Sensibilité, Spécificité

PERF <- cbind(CM[,1]+CM[,4],CM[,1]/(CM[,1]+CM[,4]),CM[,3]/(CM[,3]+CM[,2]))
PERF[PERF[,1]==0 & is.nan(PERF[,2]),2] <- 1

P <- cbind(P,PERF)

#Avec grosse exclusion par SVM Wrong
algoinc <- algo0[wrg_svm%in%c("No")]
tstinc <- tst0[wrg_svm%in%c("No")]
algoexc <- algo0[!wrg_svm%in%c("No")]
tstexc <- tst0[!wrg_svm%in%c("No")]

#Nb exclus par catégorie
CM <- conf_matrix(algoexc,tstexc,labs)
P <- cbind(P,CM[,1]+CM[,4])

#Perf sur inclus
CM <- conf_matrix(algoinc,tstinc,labs)
#Nb essais dans le GBD, Sensibilité, Spécificité

PERF <- cbind(CM[,1]+CM[,4],CM[,1]/(CM[,1]+CM[,4]),CM[,3]/(CM[,3]+CM[,2]))
PERF[PERF[,1]==0 & is.nan(PERF[,2]),2] <- 1

P <- cbind(P,PERF)

return(P)
}

