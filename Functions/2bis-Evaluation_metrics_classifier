#Precision and Recall pour classif/unclassif
####################################################
#Precision = sensibilité
Prec_class <- function(pred,data){
sum(pred&data)/sum(pred)
}
Rec_class <- function(pred,data){
sum(pred&data)/sum(data)
}
Fs_class <- function(pred,data){
2*Precision(pred,data)*Recall(pred,data)/(Precision(pred,data)+Recall(pred,data))
}
Spec_class <- function(pred,data){
sum(!pred&!data)/sum(!pred)
}

####################################################################
#Measures for multi-label classification
#Input = forme de listes de listes
#Rq: pour ces mesures on enlève les NoGBD des deux côtés
#Ou bien on peut donner 0 au groupe NoGBD

#On donne le gpe 0 aux classif vides pour formule dans l'algèbre du pb =)
AjoutZ <- function(d){
data0 <- d
data0[unlist(lapply(data0,length))==0] <- 0
return(data0)
}

#####################################################################
#Trial based measures
#####################################################################

SubsetAcc <- function(algo0,data0){
#Exact match ratio
mean(as.numeric(unlist(lapply(1:length(data0),function(i){setequal(data0[[i]],algo0[[i]])}))))
}

sym_diff <- function(a,b) setdiff(union(a,b), intersect(a,b))

HammingLoss <- function(algo0,data0,lab){
#lab désigne la taille de l'espace des labels
mean(as.numeric(unlist(lapply(1:length(data0),function(i){length(sym_diff(data0[[i]],algo0[[i]]))}))))/lab
}

Acc_t <- function(algo0,data0){
#Mean of Percentages of overall match
mean(unlist(lapply(1:length(data0),function(i){length(intersect(data0[[i]],algo0[[i]]))/length(unique(union(algo0[[i]],data0[[i]])))})))
}

Prec_t <- function(algo0,data0){
#Mean of Percentages of retrieved categories that are relevant
#On donne le gpe 0 aux classif vides pour formule dans l'algèbre du pb =)
mean(unlist(lapply(1:length(data0),function(i){length(intersect(data0[[i]],algo0[[i]]))/length(algo0[[i]])})))
}

Rec_t <- function(algo0,data0){
#Mean of Percentages of the relevant categories that are retrieved
mean(unlist(lapply(1:length(data0),function(i){length(intersect(data0[[i]],algo0[[i]]))/length(data0[[i]])})))
}

###################################################################
#Category based measures
###########################################

#True positives pour la catégorie gbd (%in%0:171)
TP <- function(algo0,data0,gbd){
sum(as.numeric(unlist(lapply(data0,function(x){gbd%in%x})))*as.numeric(unlist(lapply(algo0,function(x){gbd%in%x}))))
}

#False positives
FP <- function(algo0,data0,gbd){
sum(as.numeric(unlist(lapply(data0,function(x){!gbd%in%x})))*as.numeric(unlist(lapply(algo0,function(x){gbd%in%x}))))
}

#True negatives
TN <- function(algo0,data0,gbd){
sum(as.numeric(unlist(lapply(data0,function(x){!gbd%in%x})))*as.numeric(unlist(lapply(algo0,function(x){!gbd%in%x}))))
}

#False negatives
FN <- function(algo0,data0,gbd){
sum(as.numeric(unlist(lapply(data0,function(x){gbd%in%x})))*as.numeric(unlist(lapply(algo0,function(x){!gbd%in%x}))))
}

conf_matrix <- function(algo0,data0,lab_list){
do.call(rbind,lapply(lab_list,function(l){c(TP(algo0,data0,l),FP(algo0,data0,l),TN(algo0,data0,l),FN(algo0,data0,l))}))
}

Acc_l <- function(vals){
tp <- vals[1]
fp <- vals[2]
tn <- vals[3]
fn <- vals[4]
(tp+tn)/(tp+fp+tn+fn)
}

Prec_l <- function(vals){
tp <- vals[1]
fp <- vals[2]
tn <- vals[3]
fn <- vals[4]
tp/(tp+fp)
}

Rec_l <- function(vals){
tp <- vals[1]
fp <- vals[2]
tn <- vals[3]
fn <- vals[4]
tp/(tp+fn)
}

macro_av <- function(cm,fun){
mean(apply(cm,1,fun))
}

micro_av <- function(cm,fun){
fun(apply(cm,2,sum))
}

